条件比较排序的入参如下：
```
[
    {
        "conditionA": {
            "description": "a1",
            "id": 1
        },
        "conditionB": {
            "description": "a2",
            "id": 2
        },
        "moreImportant": {
            "description": "a2",
            "id": 2
        }
    },
    {
        "conditionA": {
            "description": "a1",
            "id": 1
        },
        "conditionB": {
            "description": "a3",
            "id": 3
        },
        "moreImportant": {
            "description": "a1",
            "id": 1
        }
    },
    {
        "conditionA": {
            "description": "a2",
            "id": 2
        },
        "conditionB": {
            "description": "a3",
            "id": 3
        },
        "moreImportant": {
            "description": "a3",
            "id": 3
        }
    },
    {
        "conditionA": {
            "description": "b1",
            "id": 1
        },
        "conditionB": {
            "description": "b2",
            "id": 2
        },
        "moreImportant": {
            "description": "b2",
            "id": 2
        }
    },
    {
        "conditionA": {
            "description": "b1",
            "id": 1
        },
        "conditionB": {
            "description": "b3",
            "id": 3
        },
        "moreImportant": {
            "description": "b3",
            "id": 3
        }
    },
    {
        "conditionA": {
            "description": "b2",
            "id": 2
        },
        "conditionB": {
            "description": "b3",
            "id": 3
        },
        "moreImportant": {
            "description": "b3",
            "id": 3
        }
    }
]
```
下面是检测条件比较排序存在矛盾的函数
```
function hasLogicalContradiction(data) {
    // 用于维护条件的顺序
    const order = [];
  
    // 辅助函数：获取某个条件在 order 数组中的索引
    function getIndex(condition) {
      return order.indexOf(condition);
    }
  
    // 遍历所有的比较关系
    for (const item of data) {
      const { conditionA, conditionB, moreImportant } = item;
      if (!moreImportant) continue; // 跳过没有选择更重要的情况
  
      const greater = moreImportant.description;
      const lesser = greater === conditionA.description ? conditionB.description : conditionA.description;
  
      const indexGreater = getIndex(greater);
      const indexLesser = getIndex(lesser);
  
      if (indexGreater === -1 && indexLesser === -1) {
        // 如果两个条件都不在 order 中，将它们按顺序插入
        order.push(greater, lesser);
      } else if (indexGreater !== -1 && indexLesser === -1) {
        // 如果 "greater" 已经在 order 中，而 "lesser" 不在，将 "lesser" 插入到 "greater" 后面
        order.splice(indexGreater + 1, 0, lesser);
      } else if (indexGreater === -1 && indexLesser !== -1) {
        // 如果 "lesser" 已经在 order 中，而 "greater" 不在，将 "greater" 插入到 "lesser" 前面
        order.splice(indexLesser-1, 0, greater);
      } else if (indexGreater > indexLesser) {
        console.log(order);
        // 如果 "greater" 出现在 "lesser" 之后，则存在矛盾
        return true;
      }
    }
    console.log(order);
    // 如果没有发现矛盾，返回 false
    return false;
  }
```